#!/bin/bash

#### CONFIGURATION ####
MAILDIRS=(
'/path/maildir/one'
'/path/maildir/two'
'/path/maildir/three'
)
         








VERBOSE=2 #0-4
TIME=10 #timeout for loop check in minutes
TIMEOUT_NOTIFY=50000 #notify timeout in ms
LIMIT_SUB=60 #number of SUBJCETS's character in xmpp notification
LIMIT_SUB_NOT=120 #number of SUBJECTs characters in notification
LIMIT_FROM=30 #number of FROM's characters
LIMIT_MAILS=40 #number mails showed in summary
BASEDIR="/dir/where/are/all/files"

PROCLOG="/path/of/procmail.log"
#### END CONFIGURATION ####


TMPPATH="$BASEDIR/cache"
icon="$BASEDIR/icons/mail_new.png"
iconERROR="$BASEDIR/icons//mail-mark-important.png"
iconCHECK="$BASEDIR/icons/mail-send-receive.png"
iconCHECKCOMPLETED="$BASEDIR/icons/emblem-default.png"
iconEND="$BASEDIR/icons/mail-mark-read.png"

REGISTER=$TMPPATH/notified
XMPPNOTIFY='$BASEDIR/scripts/xmpp-notify.py'
MIMEDECODER='$BASEDIR/scripts/mimedecode.pl'

## needed for some test
MAILSTAT='mailstat -k -t -s $PROCLOG'
MAILSTAT_RESET='mailstat -t $PROCLOG'

COUNTDOWN(){
    local OLD_IFS="${IFS}"
    IFS=":"
    local ARR=( $1 )
    local SECONDS=$((  (ARR[0] * 60 * 60) + (ARR[1] * 60) + ARR[2]  ))
    local START=$(date +%s)
    local END=$((START + SECONDS))
    local CUR=$START

    while [[ $CUR -lt $END ]]
    do
        CUR=$(date +%s)
        LEFT=$((END-CUR))

        printf "\r$2 %02d:%02d:%02d" \
            $((LEFT/3600)) $(( (LEFT/60)%60)) $((LEFT%60))

        sleep 1
    done
    IFS="${OLD_IFS}"
    echo "        "

}

LIBNOTIFY() {
	libicon=$1
	output=$2
	output2=$3

	if [ $VERBOSE -ge '2' ]
        then
            echo -e "$output - $output2"
            echo
        fi

	if notify-send -i $libicon "$output" "$output2" -t $TIMEOUT_NOTIFY &> $TMPPATH/notify-output
	then
		rm $TMPPATH/notify-output
	else
		notify-send "check_new_mail message error" "`cat $TMPPATH/notify-output`"
		rm $TMPPATH/notify-output
	fi	
}

#count new mail and update summary head
NEWMAILCOUNT() {
    #to summary
    echo > $TMPPATH/summary-head
    for i in ${MAILDIRS[@]}
    do
	NUMB=`find $i/new -type f | wc -l`
	(( TOT+=NUMB ))
	
	#to summary
	if [ ! $NUMB -eq 0 ]
	then
	    echo "`basename $i` ($NUMB)" >> $TMPPATH/summary-head
	fi
		
    done
    echo "$TOT" 
    #to summary
    echo "$TOT" > $TMPPATH/total
}

RESET() {
    mkdir "$TMPPATH"
    echo > $REGISTER
    echo > $TMPPATH/summary-body
    echo > $TMPPATH/summary-head 
    echo > $TMPPATH/total 

    if [ $VERBOSE -ge '2' ]
    then
        echo "clean $REGISTER"
        echo "clean $TMPPATH/summary-body"
        echo "clean $TMPPATH/summary-head"
        echo "clean $TMPPATH/total"
	rm -f $TMPPATH/*-fetchmail.log	
    fi

}

#with no args update summary and count
#with "lib - std - xmpp" args makes notification
NOTIFY() {	
	TOT=0
	echo > $TMPPATH/summary-head
	for i in ${MAILDIRS[@]}
	do
		NUMB=`find $i/new -type f | wc -l`
		(( TOT+=NUMB ))
		if [ ! $NUMB -eq 0 ]
		then
			##to summary
			echo "`basename $i` ($NUMB)" >> $TMPPATH/summary-head
			##needed to update in real time the total count
			#TMPNUM=`cat $TMPPATH/total`
			
			for NM in $i/new/*
			do
				if grep -q "$NM" $REGISTER
				then
				    if [ $VERBOSE -ge '4' ]
                                    then
					echo "debug: $NM checked"
				    fi
				else
				        #####################################   
					##extract and decode from and subject
					echo "$NM" >> $REGISTER		
					
					FROM="`cat $NM | grep '^From:' | head -n1 | sed 's/^From: //;s/>//' | cut -d'<' -f2`"
					#if from is on multiline
					if ! echo $FROM | grep "@" > /dev/null
					then
					    
					    FROMLINE="`cat $NM | grep -n '^From:' | head -n1 | cut -d: -f 1`"					    
					    (( FROMLINE = FROMLINE + 1 ))					    
					    while ! echo $FROM | grep "@" > /dev/null
					    do
						FROM="`cat $NM | sed -n "$FROMLINE p"`"
					    done
					    FROM="`echo $FROM | head -n1 | sed 's/>//' | cut -d'<' -f2`"
					fi

					#cut long FROM field - print only domain mail if mail different to hotmail, gmail etc else only username
					if [ `echo $FROM | wc -c` -gt $LIMIT_FROM ]
					then
					    if echo $FROM | grep -iE "hotmail|gmail.com" > /dev/null 
					    then 
						FROM="`echo $FROM | cut -d @ -f1`"
					    else
						FROM="`echo $FROM | cut -d @ -f2`"
					    fi
					fi
					
					#some mail have parentesis - maybe an error to the way extract from
					FROM="`echo $FROM | sed 's/(.*)//'`"		

                                        #number of subject position, needed for find subject in multiline
					SUBJECTLINE="`cat $NM | grep -n '^Subject:' | head -n1 | cut -d: -f 1`"
					TOTLINENM=`cat $NM | wc -l`
					(( SUBJECTLINE = SUBJECTLINE + 1 ))

					## find subject in next line
					SUBJECT="`cat $NM | grep '^Subject:' | head -n1 `"
					SUBJECT2="`cat $NM | sed -n "$SUBJECTLINE p"`"

					while [[ $SUBJECT2 != *X-BeenThere:* ]] && \
					    [[ $SUBJECT2 != From:* ]] && \
					    [[ $SUBJECT2 != Cc:* ]] && \
					    [[ $SUBJECT2 != Content-Type:* ]] && \
					    [[ $SUBJECT2 != Message-ID:* ]] && \
					    [[ $SUBJECT2 != MIME-Version:* ]] && \
					    [[ $SUBJECT2 != Mime-Version:* ]] && \
					    [[ $SUBJECT2 != X-PHP-Originating-Script:* ]] && \
					    [[ $SUBJECT2 != Date:* ]] && \
					    [[ $SUBJECT2 != X-SA-Exim-Version:* ]] && \
					    [[ $SUBJECT2 != References:* ]] && \
					    [[ $SUBJECT2 != In-Reply-To:* ]] && \
					    [[ $SUBJECT2 != To:* ]] && \
					    [[ $SUBJECT2 != Message-Id:* ]] && \
					    [[ $SUBJECT2 != Organization:* ]] && \
					    [[ $SUBJECT2 != X-Virus-Scanned:* ]] && \
					    [[ $SUBJECT2 != X-Envelope-From:* ]] && \
					    [[ $SUBJECT2 != Auto-Submitted:* ]] && \
					    [[ $SUBJECT2 != X-Greylist:* ]] && \
					    [[ $SUBJECT2 != X-Mailer:* ]] && \
					    [[ $SUBJECT2 != Reply-To:* ]]
					do
					    
					    SUBJECT=$SUBJECT$SUBJECT2
					    
					    (( SUBJECTLINE = SUBJECTLINE + 1 ))
					    SUBJECT2="`cat $NM | sed -n "$SUBJECTLINE p"`"
					    
					    #check if SUBJECTLINE is last line
					    if [ $SUBJECTLINE -gt $TOTLINENM ]
					    then
						#use a string that broke while loop
						#SUBJECT2="X-BeenThere:"
						break
					    fi
					done
					
					## find subject's type of decoding and decode it if needed
					if echo $SUBJECT | grep -iE "\=\?utf-8\?|\=\?iso-8859-1\?|\=\?iso-8859-15\?|\=\?Windows-1252\?" | grep '^Subject:' > /dev/null
					then
					    
				       	    SUBJECT=`$MIMEDECODER "$SUBJECT"`
					fi
		    					
					#remove "Subject"
					SUBJECT="`echo $SUBJECT | sed 's/^Subject: //'`"
				 
										 
					#remove square bracket of mailing list
					CLEANSUBJECT="`echo $SUBJECT | sed 's/\[.*\]//'`"
					CLEANSUBJECT="`echo $CLEANSUBJECT | sed 's/^ //'`"

					#cut long subject to xmpp
					if [ `echo $CLEANSUBJECT | wc -c` -gt $LIMIT_SUB ]
					then 
						SHORTSUBJECT="`echo $CLEANSUBJECT | cut -b1-$LIMIT_SUB`"
						SHORTSUBJECT=$SHORTSUBJECT'..'
					else
						SHORTSUBJECT=$CLEANSUBJECT
					fi
					
					#cut long subject to libnotify
					if [ `echo $CLEANSUBJECT | wc -c` -gt $LIMIT_SUB_NOT ]
					then 
						SHORTSUBJECT2="`echo $CLEANSUBJECT | cut -b1-$LIMIT_SUB`"
						SHORTSUBJECT2=$SHORTSUBJECT2'..'
					else
						SHORTSUBJECT2=$CLEANSUBJECT
					fi

					##fix problem with pango like xml encoding
					## by https://trac.openxdata.org/attachment/wiki/EncodingXMLForLiquibase/encode-xml.bash
					SHORTSUBJECTPANGO=\
"`echo $SHORTSUBJECT | sed 's/&/&amp;/g;s/>/\&gt;/g;s/</\&lt;/g;s/\"/\&quot;/g;s/\r/\&\#13;/g;:a;N;$!ba;s/\n/\&\#10;/g'`"

					#another way but not work - use recode ..html
					#SHORTSUBJECTPANGO="`echo $SHORTSUBJECT | recode -f ..html`"

					echo "<span foreground=\"#000000\">`date +"%a %d %b %H:%M"`</span>  [`basename $i`] <b><span foreground=\"#000000\"> $FROM </span></b> $SHORTSUBJECTPANGO" >> $TMPPATH/summary-body		
										
					####NOTIFICATIONS
					case $1 in
					stdout)
						echo "$FROM || $CLEANSUBJECT"
						sleep 0.3s
					;;
					
					xmpp)
						$XMPPNOTIFY "mail: [`basename $i`] $SHORTSUBJECT
						"
						sleep 2s
					;;
					
					libnotify)
						LIBNOTIFY $icon "`basename $i`" "$FROM \n$SHORTSUBJECT2"
						sleep 2s			
					;;
					
					all)
						echo "$FROM || $SUBJECT"
						$XMPPNOTIFY "mail: [`basename $i`] $SHORTSUBJECT
						"
						LIBNOTIFY $icon "`basename $i`" "$FROM \n$SHORTSUBJECT2"	
						sleep 0.3s
					;;					
					esac
					
				fi
			done
		fi	
	done
	
	##to summary
	echo >> $TMPPATH/summary-head
	echo "$TOT" > $TMPPATH/total
		
	#if [ $TOT -eq 0 ] 
	#then 
		##not necessary
		#RESET
	#fi
	#echo $TOT
}

MYfetchmail(){
    if  pidof fetchmail > /dev/null
    then
	LIBNOTIFY $iconEND "fetchmail" "another fetchmail are running"
    else
	touch $TMPPATH/fetchmail.log
	fetchmail --logfile $TMPPATH/fetchmail.log
	if cat $TMPPATH/fetchmail.log | grep "error" > /dev/null
	then
	    LIBNOTIFY $iconERROR "fetchmail" "`cat $TMPPATH/fetchmail.log | grep -A1 -B1 'error' | head -n5`"
	else
	    if cat $TMPPATH/fetchmail.log | grep "DNS" > /dev/null
	    then
		LIBNOTIFY $iconERROR "fetchmail" "`cat $TMPPATH/fetchmail.log | grep -A1 -B1 'DNS' |head -n5`"
	    else
		if [ $VERBOSE -ge 3 ]
                then
		    LIBNOTIFY $iconCHECKCOMPLETED "fetchmail" "download done successfull"
		else
		    return 0
		fi
	    fi
	fi
	mv $TMPPATH/fetchmail.log $TMPPATH/`date +%Y%m%d-%H%M`-fetchmail.log
    fi

}

	
##### MAIN #############
#########################

case $1 in

summary)
        #build summary head (maildir name with number of new mail)
	TOTNUM=`NEWMAILCOUNT`
	if [ `cat $TMPPATH/total` -eq 0 ]
	then
	    LIBNOTIFY $iconEND "summary" "<br>No Mails"
	    RESET
	else
	    ##remove title of mail in summary that moved from new to cur and clean "notified mail" register
	    VAR=1
	    cp $TMPPATH/notified $TMPPATH/tmp-notified
	    while read line
	    do
		if [ ! -e $line ]
		then
		    cat $TMPPATH/summary-body | sed "$VAR d" > $TMPPATH/tmp
		    mv $TMPPATH/tmp $TMPPATH/summary-body
		    cat $TMPPATH/tmp-notified | sed "$VAR d" > $TMPPATH/tmp2
		    mv $TMPPATH/tmp2 $TMPPATH/tmp-notified
		else
		    (( VAR++ ))
		fi
	    done < $TMPPATH/notified
	    mv $TMPPATH/tmp-notified $TMPPATH/notified
		
	    #build all if I updated only head or only body summary
	    if [ `cat $TMPPATH/total` != `cat  $TMPPATH/summary-body | sed '/^$/d' | wc -l` ]
	    then 
		NOTIFY
	    fi
		
	    ##cut if have much mails
	    if [ `cat $TMPPATH/summary-body | wc -l` -gt $LIMIT_MAILS ]
	    then	
		tac $TMPPATH/summary-body | head -n $LIMIT_MAILS > $TMPPATH/tmp-summary
		(( REST = TOTNUM - LIMIT_MAILS))
		echo "..." >> $TMPPATH/tmp-summary
		echo "others $REST mails" >> $TMPPATH/tmp-summary

		cat $TMPPATH/summary-head > $TMPPATH/summary
		echo >> $TMPPATH/summary
		cat $TMPPATH/tmp-summary >> $TMPPATH/summary

		rm $TMPPATH/tmp-summary
	    else
		cat $TMPPATH/summary-head > $TMPPATH/summary
		echo >> $TMPPATH/summary
		tac $TMPPATH/summary-body >> $TMPPATH/summary
	    fi
	    
	    case $2 in
		std)
		    while read line
		    do
			echo $line | w3m -dump -T text/html
			echo
		    done <  $TMPPATH/summary 
		    ;;
		*) LIBNOTIFY $iconEND "summary" "`cat $TMPPATH/summary`" ;;
	    esac
fi
;;

summary-conky)
	CTOT=0
	STRING=""
	for i in ${MAILDIRS[@]}
	do
		CNUMB=`find $i/new -type f | wc -l`
		(( CTOT+=CNUMB ))
		if [ ! $CNUMB -eq 0 ]
		then
		    STRING=$STRING"\${color}`basename $i| cut -b1-50` ($CNUMB) \${color1}| " 
		fi
	done
	echo "\${color1}new mail ($CTOT):"
	
	echo "`echo $STRING | sed 's/|$//'` \${color}"
	
;;

###check new mail and notify every TIME
loop)
	loop-func(){
	    clear
	    echo "CTRL+C to stop"
	    while [ 1 ]
	    do
		MYfetchmail
		NOTIFY $1
		if [ $VERBOSE -ge 2 ]
                then
                    echo
                    COUNTDOWN 00:$TIME:00 "new check from"
                else
		    sleep $TIME"m"
		fi
	    done
	}

	case $2 in

	    xmpp) 
		loop-func xmpp
		;;

	    std) 
		loop-func stdout
		;;

	    '') 
		loop-func libnotify
		;;

	    *) echo "\"$2\" not valid"

	esac

	;;

###one notification
notify)
	case $2 in
	    all) NOTIFY all;;
	    std) NOTIFY stdout;;
	    xmpp) NOTIFY xmpp;;
	    '') NOTIFY libnotify;;
	    *) echo "\"$2\" not valid"
	esac
	;;

###set new mail as seem - TODO
likeSeem)
	echo "TODO"
	;;

###reset summary and register
reset)
	RESET
	;;

###update mail and notify
updateALL)
	LIBNOTIFY $iconCHECK "mail" "launching fetchmail"
	MYfetchmail
	NOTIFY libnotify
	LIBNOTIFY $iconEND "mail" "control completed"
	;;

    count)
	NEWMAILCOUNT
	;;

    mailstat)
	$MAILSTAT
	;;
    
    mailstatReset)
	$MAILSTAT_RESET
	;;

*)
	    echo "use with:"
	    #cat $0 | grep ^[a-zA-Z][a-zA-Z]*\) | sed 's/)//' | sort -d
	    echo
	    echo "
loop std|xmpp|NULL - fetch mail and notify new mail every TIME seconds (NULL with libnotify)
notify std|xmpp|NULL - notify if it find new mail (NULL with libnotify)
summary std|NULL - summary of new mail (NULL with libnotify)
reset - reset memory of new mail arrived
updateALL - fetch mail and notify new mail one time
count - return number of new mail
likeSeem - TODO

summary-conky

mailstat - procmail mailstat
mailstatReset - reset stats
"


;;

esac



